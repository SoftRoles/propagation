#if defined COMPILE_AS_SCRIPT
#include <iostream>
#include <args.hxx>
#endif

#include <exception>
#include <math.h>

namespace softroles {
namespace propagation {

float pathLoss(float f, float d) {
  try {
    return 32.44 + 20*std::log10(f*d);
  }
  catch(std::exception& e) {
#if defined COMPILE_AS_SCRIPT || COMPILE_AS_SERVICE
    std::cout << e.what() << std::endl;
#endif
  }
}

} // end of namespace propagation
} // end of namespace softroles

#if defined COMPILE_AS_SERVICE
#include <bsoncxx/builder/basic/document.hpp>
#include <bsoncxx/builder/basic/kvp.hpp>
#include <bsoncxx/json.hpp>
#include <bsoncxx/string/to_string.hpp>
#include <mongocxx/change_stream.hpp>
#include <mongocxx/client.hpp>
#include <mongocxx/instance.hpp>
#include <mongocxx/pool.hpp>
#include <mongocxx/uri.hpp>

void watch_until(const mongocxx::client& client,
                 const std::chrono::time_point<std::chrono::system_clock> end) {
  mongocxx::options::change_stream options;
  // Wait up to 1 second before polling again.
  const std::chrono::milliseconds await_time{1000};
  options.max_await_time(await_time);

  auto collection = client["favorites"]["links"];
  mongocxx::change_stream stream = collection.watch(options);

  while (std::chrono::system_clock::now() < end) {
    for (const auto& event : stream) {
      std::cout << bsoncxx::to_json(event) << std::endl;
      if (std::chrono::system_clock::now() >= end)
        break;
    }
  }
}
#endif

#if defined COMPILE_AS_SCRIPT || COMPILE_AS_SERVICE

using namespace softroles::propagation;

int main(int argc, char **argv) {
#if defined COMPILE_AS_SCRIPT
  args::ArgumentParser parser("Radio wave propagation path loss.", "Ref: \n");
  args::Group group(parser, "Floating number arguments:", args::Group::Validators::All);
  args::Positional<float> freq(group, "freq", "Frequency in MHz");
  args::Positional<float> dist(group, "dist", "Distance in km");
  try
  {
    parser.ParseCLI(argc, argv);
  }
  catch (args::Help)
  {
    std::cout << parser;
    return 0;
  }
  catch (args::ParseError e)
  {
    std::cerr << e.what() << std::endl;
    std::cerr << parser;
    return 1;
  }
  catch (args::ValidationError e)
  {
    std::cerr << "Usage:" /*<< e.what() */<< std::endl;
    std::cerr << parser;
    return 1;
  }
  if (freq) {
    std::cout << "freq: " << args::get(freq) << std::endl;
  }
  if (dist) {
    std::cout << "dist: " << args::get(dist) << std::endl;
  }
  std::cout << pathLoss(args::get(freq), args::get(dist)) << std::endl;

  return 0;
#else
  mongocxx::instance inst {};
  mongocxx::pool poll{mongocxx::uri{}}

  try {
    auto entry = pool.acquire();

    if (get_server_version(*entry) < "3.6") {
      std::cerr << "Change streams are only supported on Mongo versions >= 3.6." << std::endl;
      // CXX-1548: Should return EXIT_FAILURE, but Travis is currently running Mongo 3.4
      return EXIT_SUCCESS;
    }

    // End in 10 seconds:
    const auto end = std::chrono::system_clock::now() + std::chrono::seconds{30};

    watch_until(*entry, end);

    return EXIT_SUCCESS;
  } catch (const std::exception& exception) {
    std::cerr << "Caught exception \"" << exception.what() << "\"" << std::endl;
  } catch (...) {
    std::cerr << "Caught unknown exception type" << std::endl;
  }

  return EXIT_FAILURE;
#endif

}

#endif
